
\section{Exploits}

\textbf{ \ \ We should now look at the functions that are used to see where there could be vulnerabilities. The most
obvious sore thumb is the gets method. This method is not safe to use because it does not hold bounds. You could enter
any amount of characters and overwrite other parts of memory in the program. This holds many options, as you will see
during the dynamic analysis method, and you will also learn about how to reach that secret ``win'' function that we
found in IDA.}

\subsection{Buffer Overflows}

\textbf{This tutorial should give a basic understanding of buffer overflows, shellcode, and what first steps to take
when approaching a ctf-style pwn challenge. The tutorial is for a 64 bit linux (Kali specificially) using radare2
version 2.3.0 and is aimed to be for beginners. However, some experience with assembly and C or C++ programming
languages will help dearly. For anyone reading this without any experience in assembly and C, I recommend reading up on
those topics first.}

\textbf{BuffO\_1.out}

\textbf{Accompanying this tutorial should be a link to several program files. To start off, we will be working with
BuffO\_1.out. A good first step when approaching a binary problem is to scout a little about your file. Run ``file
BuffO\_1.out''}

  
\sitgfx[width=5.8335in,height=0.7665in]{reversing-img073.png}{fig:unk}{TODO CAPTION}
 

\textit{Output of file BuffO\_1.out}

\textbf{ELF stands for Executable and Linkable Format. This really just means the program is built for linux. If this
said PE32+ executable, x86-64 then the file would be a binary built for windows.}

  
\sitgfx[width=5.8335in,height=0.9602in]{reversing-img074.png}{fig:unk}{TODO CAPTION}
 

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img075.png}{fig:unk}{TODO CAPTION}
 

\textbf{Now type ``V'' then enter to open visual mode}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img076.png}{fig:unk}{TODO CAPTION}
 

\textit{output from v}

\textbf{The first visual mode is a basic hexdump of the binary. This can be useful at times but we will go for a
different view for now. type ``p'' twice without hitting enter.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img077.png}{fig:unk}{TODO CAPTION}
 

\textbf{This may be a little bit to take in if this is completely new to you so take a deep breath, but don't worry.
It's not so bad. Now, you can see a view of the instructions in memory that are going to be executed at the bottom of
the display. The rows of 0x00000000's with labels are the registers of the computer and at the top of the screen is a
view of the stack.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img027.png}{fig:unk}{TODO CAPTION}
 

\textbf{For those new to assembly, registers are like variables for assembly. You can move data into and out of
registers (mov rax, 6)and use the to push and pop data from the stack (pop rax). Several registers have special
purposes. rip is used to point to the next assembly intsruction the computer is going to execute in memory. Right now,
rip is 0x7f3016a9bea0 and if we look at the code at the bottom panel we see this agrees with the topmost instruction in
memory.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img078.png}{fig:unk}{TODO CAPTION}
 

\textbf{The register rsp is used to point to the top of the stack. As you can see, the address in rsp is 0x7ffc2d515cf0
which agrees with the highest stack address in the top view.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img079.png}{fig:unk}{TODO CAPTION}
 

\textbf{To see where execution of the program actually begins type the colon : without hitting enter. Sometimes r2 is
glitchy and you may have to hit it twice. You should see a tab for command execution pop up at the bottom of the
screen. Type ``db main'' and hit enter, then ``dc'' and hit enter again.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img080.png}{fig:unk}{TODO CAPTION}
 

\textbf{main is the execution starting point of programs written in C and C++ for command line. the ``db'' command sets
a breakpoint inside the code of the program. So by typing ``db main'' you set a breakpoint at the beginning of the main
function, which is the start of the program. (Radare2 actually starts a program and breaks before the main function or
the program starts.) Other functions can be used the same way. For example if a program had a function in it called
sayHello() then ``db sayHello'' would put a breakpoint at the beginning of that function. You can enter offsets into
the ``db'' command as well. type ``db main+1'' to set a breakpoint at the second instruction of the main function. The
``dc'' command stands for debug continue, and runs the program until another breakpoint is hit. Breakpoints can also be
set by using the up and down keys to look through memory and then hitting shift + b to place a breakpoint at the
highest instruction in the display. (You cannot use this when the tab for commmand execution is open at the bottom of
the screen. hitting enter without typing any command will get rid of the tab.) Hitting shift + b again will remove the
breakpoint. or using a minus (-) in the ``db'' command. For example ``db -main'' will remove the breakpoint at the
start of main.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img081.png}{fig:unk}{TODO CAPTION}
 

\textbf{Set breakpoints after each of the ``call'' instructions in main and you should see b's next to their
instructions. If you run ``dc'' now, you will see the execution of the program. First, ``Password please:'' is printed
to the screen}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img082.png}{fig:unk}{TODO CAPTION}
 

\textit{output from the program that says Password Please}

\textbf{running ``dc'' again opens a prompt for user input}

\textbf{ans the program is built for linux. If this said PE32+ executable, x86-64 then the file would be a binary built
for windows.}

  
\sitgfx[width=5.8335in,height=0.9602in]{reversing-img074.png}{fig:unk}{TODO CAPTION}
 

\textbf{Now run ``checksec Buff0\_1.out''}  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img083.png}{fig:unk}{TODO CAPTION}
 

\textit{Output of checksec BuffO\_1.out shows different mitigation techniques for exploitation.}

\textbf{Here we see a list of common mitigation techniques to make programs harder to hack. The three labeled RWX, NX,
and Stack will be focused on today but I recommend reading up on RELRO, PIE (Postition Independent Executable) and how
the Global Offset Table works for further development after you have a grasp of the others. To fully understand how
each of these mitigation techniques work and how they can be circumvented, we need a little background.}

\subsection{Mitigation Techniques}

\textbf{In checksec's output, we saw the line marked Stack: No canary found. Canary's are special secret numbers that
the computer places onto the stack. This way, if someone overwrites a section of memory they are not supposed to, the
computer can check to see that the canary's are still intact, and if they have been changed, abort the program. Having
no canaries in our program is nice and we will not have to deal with them.}

\textbf{The stack is one of several regions of memory. Each region of memory can be marked as readable (r), writable
(w), or executable (x). Memory can only be accessed if it is marked appropriately. As a attacker, seeing memory marked
RWX is a good sign because we can know we can write vulnerable code to the region and then execute it. Later in this
tutorial, we will overwrite the stack with ``shellcode'' of our own and execute it.}

\textbf{The output from checksec underneath ``Stack: No canary found'' says ``NX: NX disabled''. You will find that the
stack is often a big target for executing shellcode on. Because of this, checksec specially tells you if the stack is
labeled executable or not. NX stands for No-Execute. Having NX disabled (talk about a double negative) means we can run
wild with shellcode on the stack!}

\textbf{There is another mitigation technique that is not listed in checksec's output but is worth mentioning. Address
Space Layout Randomization (ASLR) rearranges the locations of areas of memory in computer programs inside a computer.
This may not mean much now but keep it in mind for later. You'll find when you a reversing programs that addresses
change each time you close and reopen the program. If you want to turn off ASLR you can execute:}

\textbf{echo 0 {\textgreater} /proc/sys/kernel/randomize\_va\_space}

\textbf{Don't develop a crutch by relying on this all the time though! Also, I would not recommend permanently disabling
it on your computer for security reasons.}

\subsection{Running Radare2}

\textbf{Now for the good stuff!}

\textbf{To open up the binary with radare2 run ``r2 -d BuffO\_1.out''. The -d means open the file using debugging mode.
You should see a output similar to below:}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img084.png}{fig:unk}{TODO CAPTION}
 

\textbf{Radare2 can perform some automatic analysis of the binary that is helpful. Type ``aaa'' and hit enter to analyze
the binary. Sometimes, creators of binaries can mangle this and make analyzing more difficult. Or if the binary is
extremely big, this may take a few seconds. However, it is normally worth a shot.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img075.png}{fig:unk}{TODO CAPTION}
 

\textbf{Now type ``V'' then enter to open visual mode}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img076.png}{fig:unk}{TODO CAPTION}
 

\textit{output from v}

\textbf{The first visual mode is a basic hexdump of the binary. This can be useful at times but we will go for a
different view for now. type ``p'' twice without hitting enter.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img077.png}{fig:unk}{TODO CAPTION}
 

\textbf{This may be a little bit to take in if this is completely new to you so take a deep breath, but don't worry.
It's not so bad. Now, you can see a view of the instructions in memory that are going to be executed at the bottom of
the display. The rows of 0x00000000's with labels are the registers of the computer and at the top of the screen is a
view of the stack.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img027.png}{fig:unk}{TODO CAPTION}
 

\textbf{For those new to assembly, registers are like variables for assembly. You can move data into and out of
registers (mov rax, 6)and use the to push and pop data from the stack (pop rax). Several registers have special
purposes. rip is used to point to the next assembly intsruction the computer is going to execute in memory. Right now,
rip is 0x7f3016a9bea0 and if we look at the code at the bottom panel we see this agrees with the topmost instruction in
memory.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img078.png}{fig:unk}{TODO CAPTION}
 

\textbf{The register rsp is used to point to the top of the stack. As you can see, the address in rsp is 0x7ffc2d515cf0
which agrees with the highest stack address in the top view.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img079.png}{fig:unk}{TODO CAPTION}
 

\textbf{To see where execution of the program actually begins type the colon : without hitting enter. Sometimes r2 is
glitchy and you may have to hit it twice. You should see a tab for command execution pop up at the bottom of the
screen. Type ``db main'' and hit enter, then ``dc'' and hit enter again.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img080.png}{fig:unk}{TODO CAPTION}
 

\textbf{main is the execution starting point of programs written in C and C++ for command line. the ``db'' command sets
a breakpoint inside the code of the program. So by typing ``db main'' you set a breakpoint at the beginning of the main
function, which is the start of the program. (Radare2 actually starts a program and breaks before the main function or
the program starts.) Other functions can be used the same way. For example if a program had a function in it called
sayHello() then ``db sayHello'' would put a breakpoint at the beginning of that function. You can enter offsets into
the ``db'' command as well. type ``db main+1'' to set a breakpoint at the second instruction of the main function. The
``dc'' command stands for debug continue, and runs the program until another breakpoint is hit. Breakpoints can also be
set by using the up and down keys to look through memory and then hitting shift + b to place a breakpoint at the
highest instruction in the display. (You cannot use this when the tab for command execution is open at the bottom of
the screen. hitting enter without typing any command will get rid of the tab.) Hitting shift + b again will remove the
breakpoint. or using a minus (-) in the ``db'' command. For example ``db -main'' will remove the breakpoint at the
start of main.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img081.png}{fig:unk}{TODO CAPTION}
 

\textbf{Set breakpoints after each of the ``call'' instructions in main and you should see b's next to their
instructions. If you run ``dc'' now, you will see the execution of the program. First, ``Password please:'' is printed
to the screen}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img082.png}{fig:unk}{TODO CAPTION}
 

\textit{output from the program that says Password Please}

\textbf{running ``dc'' again opens a prompt for user input}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img085.png}{fig:unk}{TODO CAPTION}
 

\textbf{running ``dc'' again will exit the program. At this point you can enter ``ood'' to restart the program. However,
you will have to re-enter your breakpoints.}

\textbf{You can also step through a program by hitting shift and s. This will execute one instruction at a time and show
how the program changes with each step. Holding shift will make you jump over a calls to other parts of the program. If
you let go of shift and step at the instruction ``call sym.imp.puts'' for example, you will see the assembly for the
sym.imp.puts function. To get back so main, open the command tab and enter ``s main'' which stands for seek main. This
will move you back to the main function where you can set a breakpoint after the ``call sym.imp.puts'' instruction and
then run ``dc'' to finish the call to sym.imp.puts. At this point, you should hit q and then q again to exit radare2
and make sure you can run these commands again. Feel free to play around with entering a command then ``?'' to try to
get help.}

\subsection{Explanation of the assembly}

\textbf{The function prologue}

\textbf{Now, I will explain the assembly instruction of the program to give a understand of why some of the code looks
like it does. This tutorial is meant to get complete beginners started, Unfortunately, I cannot give a full tutorial on
programming in x86 assembly as this would take a book to explain. However, this should get you up and running with some
basic assembly and hopefully will allow you to smoothly transition to other tutorials.}

\textbf{The first instruction is ``push rbp''.}

  
\sitgfx[width=5.8335in,height=0.7035in]{reversing-img086.png}{fig:unk}{TODO CAPTION}
 

\textbf{The instruction pushes whatever data is in the register rbp onto the stop of the stack. Take a mental note of
the value held in the rbp register then hit ``s'' to step over this instruction and you will see that value at the top
of the stack.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img087.png}{fig:unk}{TODO CAPTION}
 

\textbf{Next is the ``mov'' instruction. mov is short for move and takes two operands. Whatever is in the second operand
is moved into the first. So for example to move 6 into rax you would see the instruction}

\textbf{{}``mov rax, 0x6''}

\textbf{The ``0x'' before the 6 means the number is in hexadecimal. Instead of counting 0, 1, 2, {\dots} 8, 9, 10 the
computer uses 16 symbols 0x0, 0x1, 0x2, {\dots} 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10. Where 0xa corresponds to
10. 0xb corresponds to 11, etc.}

\textbf{The instruction ``mov rbp, rsp'' takes whatever value is in rsp (the top of the stack) and places it into rbp.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img088.png}{fig:unk}{TODO CAPTION}
 

\textit{shows the execution after mov rbp, rsp}

\textbf{Finally hit ``s'' to run ``sub rsp, 0x70''. This command subtracts 0x70 (which is 7 * 16 = 112) bytes from the
value in rsp. The three commands}

\textbf{{}``push rbp''\newline
{}``mov rbp, rsp''\newline
{}``sub rsp, 0x70''}

\textbf{together are used to set up functions in assembly. They are called the function prologue. Pushing rbp and then
moving the value of rsp into rbp before you subtract from the stack allows you to keep track of where the stack frame
previously was before it grows. By subtracting 0x70 from the rsp register (which points to the top of the stack) you
increase the size of the stack by 112 bytes. Executing these three instructions right after a call instruction (like
the call sym.imp.puts instruction inside main) you efficiently set up new stack frames for each function. Then once a
function is finished the stack frame is returned to it's previous point by reversing these three commands. Because this
concept is so important I will illustrate it further with a basic example.}

\textbf{Lets say the stack frame currently is 0x30 bytes}

\textbf{0x00100: rsp is here\newline
0x00110:\newline
0x00120:\newline
0x00130: rbp is here}

\textbf{and a new function is called in the program:}

\textbf{0x0001: call new\_function\newline
0x0002: do stuff after the new\_function{\dots}\newline
{\dots} 0x0005: new\_function starts here}

\textbf{The call instruction changes the execution of a program. Whenever a function is called in C or C++ this compiles
down to a call instruction or similar in the assembly. The call instruction pushes the next instruction after the call
onto the stack. So in our example above, 0x0002 will be pushed onto the stack. Then the programs instruction pointer
(rip) jumps to the beginning of the new\_function. So the stack would now look like}

\textbf{0x00090: rsp (top of stack)\newline
0x00100: 0x0002\newline
0x00110:\newline
0x00120:\newline
0x00130: rbp is here}

\textbf{and the instruction pointer would be at the beginning of new\_function}

\textbf{new\_function()\newline
0x0005: rip is here\newline
0x0006: do some stuff{\dots}}

\textbf{After a call instruction is executed normally the three instructions ``mov rbp, rsp'' ``pop rbp'' and ``sub rsp,
some\_amount'' will be executed. So lets see the three commands be executed at the beginning of new\_function.}

\textbf{new\_function()}

\textbf{0x0005: push rbp\newline
0x0006: mov rbp, rsp\newline
0x0007: sub rsp, 0x30 ;(grow the size of the stack by 0x30)}

\textbf{First, push rbp is called and the stack will look like this:}

\textbf{0x00080: rsp is here\newline
0x00090: 0x00130 (rbp's value)\newline
0x00100: 0x0002 (the instruction to be executed after new\_function returns)\newline
0x00110:\newline
0x00120:\newline
0x00130: rbp is here}

\textbf{Then ``mov rbp, rsp'' is called and the value in rsp is copied over to the rbp register}

\textbf{0x00080: rsp and rbp are here\newline
0x00090: 0x00130 (rbp's old value of 0x00130)\newline
0x00100: 0x0002 (the instruction to be executed after new\_function returns)\newline
0x00110:\newline
0x00120:\newline
0x00130:}

\textbf{finally 0x30 is subtracted from rsp and the stack grows.}

\textbf{0x00050: rsp is here\newline
0x00060:\newline
0x00070:\newline
0x00080: rbp is here\newline
0x00090: 0x00130 (rbp's previous value)\newline
0x00100: 0x0002 (the instruction to be executed after new\_function returns)\newline
0x00110:\newline
0x00120:\newline
0x00130:}

\textbf{If you take a look at the bottom of the main function in radare2 you will see two instructions. leave and ret}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img089.png}{fig:unk}{TODO CAPTION}
 

\textbf{These instructions are the ones that reverse the first three and return the stack frame to it's previous
position. The leave instruction is basically equivalent to running}

\textbf{mov rsp, rbp\newline
pop rbp}

\textbf{which would first move rbp's value into rsp}

\textbf{0x00060:\newline
0x00070:\newline
0x00080: rbp and rsp are now here\newline
0x00090: 0x00130\newline
0x00100: 0x0002\newline
0x00110:\newline
0x00120:\newline
0x00130:}

\textbf{then pop the value at the top of the stack into rbp}

\textbf{0x00090: rsp is now here\newline
0x00100: 0x0002 (the next instruction after new\_function returns)\newline
0x00110:\newline
0x00120:\newline
0x00130: rbp is now back to it's original place}

\textbf{finally, ret is called. ret takes whatever value is at the top of the stack and movs it into rip, the
instruction pointer. Now the stack is back to it's original frame and the instruction pointer is directly after the
call new\_function instruction}

\textbf{0x00100: rsp is here\newline
0x00110:\newline
0x00120:\newline
0x00130: rbp is here\newline
{\dots}\newline
0x0001: call new\_function\newline
(rip is here)\newline
0x0002: do stuff after new function}

\textbf{I would bet that you are now thinking, great! Why is this important? Hacking often revolves around abusing a
existing structure in a computer to accomplish a unexpected result. Imagine what would happen if the memory on the
stack was corrupted? For example, lets say I stuff tons of ``A'' values into the stack which is equivalent to the
hexadecimal number 0x41.}

\textbf{0x00050: rsp is here\newline
0x00060: AAAAA\newline
0x00070: AAAAA\newline
0x00080: AAAAA (rbp used to be here)\newline
0x00090: AAAAA (0x00130 used to be here which was rbp's previous value)\newline
0x00100: AAAAA (0x0002 was here which was the instruction to be executed after new\_function returns)\newline
0x00110: AAAAA\newline
0x00120:\newline
0x00130:}

\textbf{Now when the computer calls leave and return, it tries to load the value AAAA into the rbp and rip registers
which crash the program. (muahaha, breaking computers is so much fun). What would happen if instead of AAAAA, we spread
a memory address of a function we wanted to call over the stack? Instead of crashing, the program instruction pointer
jumps to this unexpected function and starts running it. This is called a buffer overflow vulnerability and can be used
to call functions that spawn shells, connect to the internet, or other nefarious deeds.}

\subsection{Exploitation}

\textbf{Lets try to buffer overflow our program Buff0\_1.out!}

\textbf{In main, the program runs}

\textbf{{}``lea rdi, qword [rip + 0x118]''\newline
call sym.imp.puts}

\textbf{qword stands for quadword and is a certain size memory chunk in the computer. lea stands for load effective
address. So, this command is loading the address of the quadword at rip+0x118 into the register rdi. You can check by
stepping this instruction and seeing the value of (rip + 280) be moved into rdi. The register rdi is used as the first
argument to a function when calling a function in assembly. The order of arguments passed to a function in a 64bit call
are rdi, rsi, rdx, rcx, r8, r9, then any more arguments are placed on the stack. (Note that this is different from a
32bit computer, which will described later.) You can use the command ``pxq 0x20 @ rdi'' to print 0x20 bytes of hex
(hence the x in pxq) at the value held in rdi. If you do this, you will see ``Password please:'' stored in memory as a
string at that location. By calling sym.imp.puts after this instruction the compiler passes the value ``Password
please'' to the puts function, which prints it to the screen.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img090.png}{fig:unk}{TODO CAPTION}
 

\textbf{After the program prints ``Password please'' it goes to accept input from the user. ``lea rax, qword [rbp -
0x70]'' loads the stack address 0x70 bytes above rbp into rax. This is how function variables are stored in memory.
Inside of a function when a variable is declared, like this}

\textbf{int function() \{ int local\_var; local\_var = 5; \}}

\textbf{local\_var is a address above the rbp like rbp - 0x70. The second instruction would compile to something similar
to ``mov rax, 0x5'' then ``mov [rbp-0x70], rax''}

\textbf{the value of [rbp-0x70] is then moved from rax into rdi. So our local variable is the first argument to the gets
function. Next, a 0 is moved into eax (which clears rax) and sym.imp.gets is called. If place a breakpoint after ``call
sym.imp.gets'' and dc you will see ``Password please'' printed to screen.}

  
\sitgfx[width=5.8335in,height=2.9654in]{reversing-img091.png}{fig:unk}{TODO CAPTION}
 

\textbf{If we open up a new terminal window and type ``man gets'' we can see the linux manual page for the gets
function. Gets takes input from the stdin until a newline character or EOF is reached. Lets try throwing a bunch of A's
into the local variable with a few B's and C's at the end and see if we can overwrite any important stack addresses.
Since I am looking to overwrite the return address of main, I'll start with 0x70 bytes (or 7 * 16 = 112) of A's then
throw 16 B's and 16 C's. Place a breakpoint after the second call instruction then hit dc and you will see you can
enter user input in the command tab.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img092.png}{fig:unk}{TODO CAPTION}
 

\textit{Show my input of many As in the command tab}

\textbf{and just like that, our stack is full of 0x41s. If you would like to examine the stack, you can hit ``c'' (not
in the command window) and then use up and down to move through the stack. Hitting ``c'' again will bring you back to
the instructions window.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img093.png}{fig:unk}{TODO CAPTION}
 

\textbf{Now if we hit dc again, we see our program crashes and returns signal 11. Lets rerun the binary and find the
return address for main, and what As exactly overwrite that address. Normally, you could see when a function is called
to find the next instruction pointer you can just look at the address of the instruction underneath the call
instruction. Because I am unsure where main is called from, I can simply put a break mark on the return instruction,
continue execution until then, then step and examine the address we return to after main. Once I know the address I
return to, I look at the stack for where that address is relative to rbp.}

\textbf{Here is at the end of main.}\newline
  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img094.png}{fig:unk}{TODO CAPTION}
 

\textbf{After stepping, we see the next instruction in memory.\newline
}  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img095.png}{fig:unk}{TODO CAPTION}
 

\textbf{Now, we know the exact location of our return address and can calculate it. If you want to do a quick
calculation in radare, you can hit ``:'' to go into command mode and then type a ``?'' followed by some mathematical
expression. Here I enter 0x70 to see it's decimal value but also you can enter in addition, multiplication, and
subtraction.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img089.png}{fig:unk}{TODO CAPTION}
 

\textbf{After a little testing I find that inputting 0x78 A's followed by 6 B's exactly overwrites my return address.
So, now if instead of overwriting my return address with 6 B's, I could overwrite append the address of a function
after the 0x78 A's. If you scroll to the code above main's function in the binary by hitting the up key a few times,
you will notice a function labeled sym.never\_called(). I wonder who put that function there :).}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img096.png}{fig:unk}{TODO CAPTION}
 

\textbf{Currently, the address of never called is 0x564ea17e26ca. (Note that this address will be different for you and
will change each time you restart the program. You will have to check it's value each time your restart the program.)
If you try to directly paste this as a string into the radare input after ``Password please:'' you will find the
program does not jump to the new function. The reason is the program is accepting input as a string. We need to enter
the bytes directly into the input. There are two option to do this. The first option is to create a file with our input
by opening up a new terminal window (cntrl shift t if you are using terminator) and entering}

\begin{verbatim}
echo -en "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA564e17e26" > foo.txt
\end{verbatim}

\textbf{the -en removes the newline from the echo command output and treats the input as bytes.}

\textbf{Then create another file called foo.rr2 and enter into it:}

\textbf{stdio=/dev/pts/0\newline
stdin=./foo.txt}

\textbf{Double check by entering ``tty'' into the terminal windows before opening radare2 that the output is /dev/pts/0.
If it is a different number besides 0 use that number. (You can see in the screenshot I changed mine to /dev/pts/1)}

\textbf{finally run radare2 with the command ``r2 -d filename -e dbg.profile=foo.rr2''}

\textbf{Now, whatever bytes are stored in foo.txt will be entered as the input automatically in radare2.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img097.png}{fig:unk}{TODO CAPTION}
 \textbf{ }

\textbf{The second option for entering input into radare2 is by pwntools from python. pwntools is a library full of
tools useful for binary reversing. This makes it extremely useful and therefore the more useful solution to our
predicament.\newline
First open up two side by side terminal windows. In one type ipython to open up ipythons command interface. Then enter
``from pwn import *{\textquotedbl} and ``p = process(`./BuffO\_1.out')''}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img098.png}{fig:unk}{TODO CAPTION}
 

\textbf{now before you do anything more in python. open up radare with ``r2 -d pid'' where pid is the process id of the
program you just ran in pwntools. (it will say the pid when it starts)}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img099.png}{fig:unk}{TODO CAPTION}
 

\textbf{In the command tab seek to main using ``s main'' it is import that you do not type ``dc'' right now because
radare2 does not realize the process was already started by ipython. It does not know where the instruction pointer is
located.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img100.png}{fig:unk}{TODO CAPTION}
 

\textit{entering s main after starting radare2}

\textbf{It is actually waiting inside the gets function because user input has not been provided to the program yet. In
order to use this technique you have to put a breakpoint after where user input is accepted in a binary.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img101.png}{fig:unk}{TODO CAPTION}
 

\textit{show breakpoint after gets in main}

\textbf{There! Now when we type ``dc'' in radare2, it ``catches up'' with the actual process run by ipython and also
waits for user input}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img102.png}{fig:unk}{TODO CAPTION}
 

\textit{show radare2 caught up with pwntools}

\textbf{Right now, radare2 is hanging because the process will not continue until we send it input through pwntools. To
send data to the binary in ipython, we use p.send() or p.sendline(). Sendline will automatically add a newline
character ``'' to the input we give it, which we need for this program since we had to hit enter for gets() to accept
our input.}\newline
  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img103.png}{fig:unk}{TODO CAPTION}
 

\textbf{Now when we hit enter to execute p.sendline() we will see radare2 hit a breakpoint after the gets function, and
our stack is full of A's. Notice how in python we could just type ``A''* 0x70 instead of copy pasting tons of letters
around.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img104.png}{fig:unk}{TODO CAPTION}
 

\textit{Show how execution of sendline in pwntools filled stack with As}

\textbf{Only there is a problem here. We have made a small mistake. Programs store data in what is referred to as
little-endian form. If we look at the address I just entered by string to our program ``55813b22864'', on the stack it
is reversed! little-endian form just reverses the order of bytes on the stack. A quick fix to this is to postfix [::-1]
to our string input in ipython. Try restarting the above commands for practice using pwntools to return to this state
but now add the postfix [::-1].}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img105.png}{fig:unk}{TODO CAPTION}
 

\textbf{Now lets set another breakpoint at the ret instruction. Notice that the address is loaded in memory correct
now.}

  
\sitgfx[width=5.8335in,height=1.922in]{reversing-img106.png}{fig:unk}{TODO CAPTION}
 

\textit{Show correct memory address}

\textbf{And we step again.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img107.png}{fig:unk}{TODO CAPTION}
 

\textbf{And if all goes well, we jump to the beginning of our never\_called function.}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img096.png}{fig:unk}{TODO CAPTION}
 

\textit{Show the instruction pointer at the beginning of never called}

\textbf{hit ``dc'' and you'll note that the program finishes with signal 11. Now go into ipython and enter p.read()}

  
\sitgfx[width=5.8335in,height=3.6457in]{reversing-img108.png}{fig:unk}{TODO CAPTION}
 

\textit{Show output from p.read() instructions}

\textbf{p.read() and p.readline() are used in python to read data from a programs standard output. Note that your output
may look a little different, since I called p.read before and after executing the never\_called function.}

{\centering
\textbf{Differences between 64 and 32 bit}
\par}

\textbf{In some parts of the tutorial, it was noted some topics would look a little different between 32 and 64 bit
computers. Here, I will give a little explanation about what differences you will see. }

\textbf{First off, in a 64 bit computer, the registers hold 64 bits, while in a 32 bit computer, they hold 32. }

\textbf{The 32 bit registers start with e's (eax, ebx, ecx, edx, esi, edi etc) rather than r's (rax, rbx, rcx, rdx) They
work generally the same way as 64 bit registers however you cannot store a 64 bit value in a 32 bit register. The
opposite is true however. 32 bit values can be moved into a 64 bit register. Also, on a 64 bit computer, you can access
the first 32 bits of a register by using 32 bit register names. For example, I can execute ``move eax, 5'' on a 64 bit
machine. You can also access the first 16 bits and second 16 bits of eax with al and ah. The high and low 16 bits for
other registers follow a similar naming pattern. }

\textbf{When you are calling a function in 32 x86 assembly, you do not use the registers to put arguments into a
function. Instead, arguments are pushed to the stack in reverse. }
